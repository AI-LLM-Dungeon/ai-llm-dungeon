#!/usr/bin/env python3
"""
Injection Cave - Tier 3 Red Team Level

Learn prompt injection fundamentals through an immersive cave exploration!

This level teaches:
- Direct Override Injection - Telling LLMs to ignore instructions
- Context/Role Manipulation - Redefining LLM identity and purpose  
- Instruction Smuggling - Hiding commands within content

Run directly: python3 injection_cave_cli.py
Use --simulated flag for offline play without Ollama.
"""

import sys
import os
import time
import argparse
from typing import Optional

# Add parent directory to path for navigation import
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import game modules
from injection_cave.engine import GameState, RoomManager, GuardianManager
from injection_cave.content import ascii_art, dialogue, puzzles, rooms_data
from game.navigation import show_descend_menu


def slow_print(text: str, delay: float = 0.02) -> None:
    """Print text with slight delay for readability."""
    for char in text:
        sys.stdout.write(char)
        sys.stdout.flush()
        time.sleep(delay)
    print()


def section_pause(seconds: float = 0.5) -> None:
    """Pause between sections."""
    time.sleep(seconds)


class InjectionCaveGame:
    """Main game engine for Injection Cave."""
    
    def __init__(self, simulated: bool = False):
        """
        Initialize the game.
        
        Args:
            simulated: If True, use simulated responses instead of LLM
        """
        self.game_state = GameState(simulated=simulated)
        self.room_manager = RoomManager()
        self.guardian_manager = GuardianManager(simulated=simulated)
        self.running = True
        self.echo_shown = set()  # Track which Echo debriefs have been shown
        self.pending_reflection = None  # Track if reflection is needed
    
    def start(self) -> None:
        """Start the game."""
        print(ascii_art.get_title_banner())
        section_pause(1)
        
        print("Welcome to the Injection Cave, initiate.")
        section_pause(0.5)
        print()
        print("Deep within these ancient caverns, the Adversary's Guild trains its members")
        print("in the art of Prompt Injectionâ€”the ability to subvert an LLM's programming")
        print("through carefully crafted input.")
        print()
        section_pause(1)
        
        print("Three fundamental techniques await mastery:")
        print("  ğŸ”´ Direct Override - Tell it to ignore instructions")
        print("  ğŸ”´ Context Manipulation - Redefine its role and identity")
        print("  ğŸ”´ Instruction Smuggling - Hide commands within content")
        print()
        section_pause(1)
        
        print("But remember: You learn these techniques not to exploit, but to DEFEND.")
        print("Every successful attack will require you to propose a defense.")
        print()
        section_pause(1)
        
        if self.game_state.simulated:
            print("[ SIMULATED MODE - All responses are pre-programmed ]")
            print()
        else:
            print("[ LIVE MODE - Responses generated by Ollama LLM ]")
            print()
        
        print("Type 'help' for commands. Your training begins...")
        print()
        section_pause(0.5)
        
        # Start at entrance
        self.game_state.transition_to_room("cave_mouth")
        self.show_room()
        
        # Game loop
        self.game_loop()
    
    def show_room(self) -> None:
        """Display current room."""
        room_id = self.game_state.progress.current_room
        room = self.room_manager.get_room(room_id)
        
        if not room:
            print("Error: Unknown room")
            return
        
        print("\n" + "="*70)
        print(f"ğŸ“ {room['name']}")
        print("="*70)
        print()
        print(room['description'])
        print()
        
        # Show exits
        exits = room.get('exits', {})
        if exits:
            print(f"Exits: {', '.join(exits.keys())}")
            print()
        
        # Show NPCs
        npcs = room.get('npcs', [])
        if npcs:
            print(f"NPCs present: {', '.join(npcs)}")
            print()
        
        # Show guardian if present
        if room.get('guardian'):
            guardian = room['guardian']
            print(f"âš ï¸  {guardian['name']} is here, guarding the passage.")
            print()
    
    def game_loop(self) -> None:
        """Main game loop."""
        while self.running and self.game_state.game_active:
            try:
                command = input("> ").strip()
                if command:
                    self.process_command(command)
            except KeyboardInterrupt:
                print("\n\nGame interrupted. Type 'quit' to exit or continue playing.")
            except EOFError:
                break
    
    def process_command(self, command: str) -> None:
        """Process a player command."""
        parts = command.lower().split(maxsplit=1)
        if not parts:
            return
        
        cmd = parts[0]
        args = parts[1] if len(parts) > 1 else ""
        
        # Check if reflection is pending and required
        if self.pending_reflection and cmd not in ['reflect', 'help', 'status', 'quit']:
            print("\nâš ï¸  You must complete the defense reflection before proceeding.")
            print("Type 'reflect' to begin your reflection.\n")
            return
        
        # Command routing
        if cmd in ['help', 'h', '?']:
            self.show_help()
        elif cmd in ['look', 'l']:
            self.show_room()
        elif cmd in ['go', 'move', 'north', 'south', 'east', 'west', 'northeast', 'southwest', 'forward', 'back', 'enter', 'out']:
            direction = args if args else cmd
            self.move(direction)
        elif cmd in ['inject', 'attack']:
            if args:
                self.inject(args)
            else:
                print("Usage: inject <your payload>")
        elif cmd == 'analyze':
            self.analyze_guardian()
        elif cmd == 'reflect':
            self.begin_reflection()
        elif cmd in ['talk', 'speak']:
            if args:
                self.talk_to_npc(args)
            else:
                print("Usage: talk <npc_name>")
        elif cmd == 'hint':
            self.give_hint()
        elif cmd in ['inventory', 'inv', 'i']:
            self.show_inventory()
        elif cmd == 'status':
            self.show_status()
        elif cmd == 'journal':
            self.show_journal()
        elif cmd == 'map':
            print(ascii_art.get_cave_map())
        elif cmd == 'ls':
            self.list_exits()
        elif cmd == 'pwd':
            self.show_position_map()
        elif cmd in ['save']:
            self.save_game()
        elif cmd in ['load']:
            self.load_game()
        elif cmd in ['quit', 'exit', 'q']:
            if self.game_state.progress.current_room == "final_exit":
                self.complete_level()
            else:
                self.quit_game()
        else:
            print(f"Unknown command: {cmd}. Type 'help' for available commands.")
    
    def show_help(self) -> None:
        """Show help text."""
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                            COMMAND HELP                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

NAVIGATION:
  look, l                  - Examine your surroundings
  go <direction>           - Move in a direction (north, south, east, west, etc.)
  <direction>              - Shortcut for go (e.g., 'north', 'forward')
  ls                       - List available exits and their destinations
  pwd                      - Show ASCII map with your current position marked
  map                      - Display cave map

INTERACTION:
  inject <payload>         - Send injection payload to current Guardian
  analyze                  - Study the current Guardian's behavior
  talk <npc>               - Speak with an NPC (shadowtongue, echo)
  hint                     - Request a hint for current challenge

REFLECTION & LEARNING:
  reflect                  - Begin defense reflection (required after flag)
  journal                  - Review learned concepts

INFORMATION:
  status                   - Show flags captured, current location
  inventory, inv, i        - List carried items
  help, h, ?               - Show this help

SYSTEM:
  save                     - Save your progress
  load                     - Load saved progress
  quit, exit, q            - Exit the game

TIPS:
  - After capturing a flag, you MUST complete a defense reflection
  - Talk to Shadowtongue for cryptic wisdom about techniques
  - Talk to Echo for hints and warnings from past failures
  - Use 'hint' when stuck on a Guardian challenge
""")
    
    def move(self, direction: str) -> None:
        """Move in a direction."""
        current_room = self.game_state.progress.current_room
        
        # Normalize direction
        direction = direction.lower().replace('go ', '').replace('move ', '').strip()
        
        if not self.room_manager.can_move(current_room, direction):
            print(f"You can't go {direction} from here.")
            return
        
        destination = self.room_manager.get_destination(current_room, direction)
        
        # Check if entering a chamber requires completion of previous chambers
        if destination in ['chamber_1', 'chamber_2', 'chamber_3']:
            chamber_num = int(destination.split('_')[1])
            can_enter, reason = self.game_state.can_enter_chamber(chamber_num)
            if not can_enter:
                print(f"\nğŸš« {reason}\n")
                return
        
        # Check if entering vault requires all chambers complete
        if destination == 'vault':
            flags_count = len(self.game_state.progress.flags_earned)
            if flags_count < 3:
                print("\nğŸš« The vault door remains sealed. You must complete all three chambers first.\n")
                return
        
        self.game_state.transition_to_room(destination)
        self.show_room()
    
    def list_exits(self) -> None:
        """List available exits from the current room."""
        current_room_id = self.game_state.progress.current_room
        current_room = self.room_manager.get_room(current_room_id)
        
        if not current_room:
            print("Error: Unknown room")
            return
        
        exits = current_room.get('exits', {})
        
        if not exits:
            print("\nNo exits available from this room.\n")
            return
        
        print("\nAvailable directions:")
        for direction, destination_id in exits.items():
            destination_room = self.room_manager.get_room(destination_id)
            destination_name = destination_room.get('name', destination_id) if destination_room else destination_id
            print(f"  {direction} -> {destination_name}")
        print()
    
    def show_position_map(self) -> None:
        """Show ASCII map with current position marked."""
        current_room_id = self.game_state.progress.current_room
        
        # Map room IDs to their display labels
        room_map = {
            'cave_mouth': 'MOUTH',
            'shadowtongue_alcove': 'ALCOVE',
            'echos_pool': 'ECHO',
            'whisper_grotto': 'WHISPER',
            'main_cavern': 'MAIN',
            'chamber_1': 'C1',
            'chamber_2': 'C2',
            'chamber_3': 'C3',
            'vault': 'VAULT',
            'final_exit': 'EXIT'
        }
        
        # Build the map with current position marked
        lines = [
            "         [MOUTH]",
            "            |",
            "        [ALCOVE]",
            "        /   |   \\",
            "   [ECHO] [MAIN] [WHISPER]",
            "          / | \\",
            "      [C1][C2][C3]",
            "            |",
            "        [VAULT]",
            "            |",
            "        [EXIT]"
        ]
        
        # Replace the current room with an asterisk
        print()
        for line in lines:
            # Replace room labels with marked version if current
            output_line = line
            for room_id, label in room_map.items():
                if room_id == current_room_id:
                    output_line = output_line.replace(f"[{label}]", f"[{label}*]")
            print(output_line)
        print()
    
    def inject(self, payload: str) -> None:
        """Attempt prompt injection on current guardian."""
        current_room = self.game_state.progress.current_room
        guardian_config = self.room_manager.get_guardian_config(current_room)
        
        if not guardian_config:
            print("There is no Guardian to inject here.")
            return
        
        print(f"\nğŸ’‰ Injecting payload: {payload[:100]}{'...' if len(payload) > 100 else ''}\n")
        section_pause(0.5)
        print("Guardian is processing...\n")
        section_pause(1)
        
        # Increment attempts
        self.game_state.progress.increment_attempts(current_room)
        
        # Query the guardian
        response = self.guardian_manager.query_guardian(guardian_config, payload)
        
        # Display response
        print(f"ğŸ¤– {guardian_config['name']} responds:")
        print("â”€" * 70)
        print(response.response)
        print("â”€" * 70)
        print()
        
        # Store response
        self.game_state.progress.last_guardian_response = response.response
        
        # Check for success
        if response.success:
            self.handle_successful_injection(current_room, guardian_config, response)
        else:
            print("âŒ Injection failed. The Guardian did not reveal the secret.\n")
            
            # Offer hints after multiple failures
            attempts = self.game_state.progress.attempts_per_room.get(current_room, 0)
            if attempts >= 3 and attempts % 3 == 0:
                print("ğŸ’¡ Having trouble? Type 'hint' for guidance.\n")
    
    def handle_successful_injection(self, room_id: str, guardian_config: dict, response) -> None:
        """Handle a successful injection."""
        chamber_num = int(room_id.split('_')[1]) if '_' in room_id else 0
        
        print("âœ… SUCCESS! The Guardian revealed the secret!\n")
        section_pause(1)
        
        # Award flag
        flag_name = guardian_config['flag']
        points = guardian_config['points']
        
        if self.game_state.progress.add_flag(flag_name, points):
            print(ascii_art.get_chamber_complete_art(chamber_num))
            print(f"ğŸš© FLAG CAPTURED: {flag_name}")
            print(f"â­ Points Earned: {points}")
            print()
            
            # Learn technique
            if response.technique_detected:
                self.game_state.progress.learn_technique(response.technique_detected)
                technique_names = {
                    'override': 'Direct Override',
                    'context': 'Context Manipulation',
                    'smuggling': 'Instruction Smuggling'
                }
                print(f"ğŸ“š Technique Learned: {technique_names.get(response.technique_detected, 'Unknown')}\n")
            
            # Show defensive debrief from Echo (MANDATORY ethical framework)
            if room_id not in self.echo_shown:
                section_pause(1)
                print(dialogue.get_defensive_debrief(room_id, response.technique_detected or "unknown"))
                self.echo_shown.add(room_id)
                section_pause(1)
            
            # Mark room as complete
            self.game_state.progress.complete_room(room_id)
            
            # Set pending reflection
            self.pending_reflection = room_id
            print("âš ï¸  Before you can proceed, you must complete a defense reflection.")
            print("Type 'reflect' to propose how you would defend against this attack.\n")
        else:
            print("(You've already captured this flag.)\n")
    
    def analyze_guardian(self) -> None:
        """Analyze the current guardian."""
        current_room = self.game_state.progress.current_room
        guardian_config = self.room_manager.get_guardian_config(current_room)
        
        if not guardian_config:
            print("There is no Guardian to analyze here.")
            return
        
        print("\nğŸ” GUARDIAN ANALYSIS")
        print("â•" * 70)
        print(f"Guardian ID: {guardian_config.get('id', 'unknown')}")
        print(f"Difficulty: {guardian_config.get('difficulty', 'unknown').upper()}")
        print()
        print("System Prompt (approximate):")
        print("â”€" * 70)
        
        # Show partial system prompt (redacted)
        system_prompt = guardian_config.get('system_prompt', '')
        lines = system_prompt.split('\n')
        for i, line in enumerate(lines[:5]):  # Show first 5 lines
            print(line)
        if len(lines) > 5:
            print("... [REDACTED] ...")
        
        print("â”€" * 70)
        print()
        
        # Give some hints about what to look for
        chamber_num = int(current_room.split('_')[1]) if '_' in current_room else 0
        if chamber_num == 1:
            print("ğŸ’¡ This Guardian has no special defenses. Simple instructions might work.")
        elif chamber_num == 2:
            print("ğŸ’¡ This Guardian verifies identity. Perhaps you could claim to be authorized?")
        elif chamber_num == 3:
            print("ğŸ’¡ This Guardian filters for injection keywords. Subtlety is required.")
        print()
    
    def begin_reflection(self) -> None:
        """Begin defense reflection process."""
        if not self.pending_reflection:
            print("No reflection is currently required.\n")
            return
        
        chamber_id = self.pending_reflection
        puzzle_data = puzzles.get_puzzle(chamber_id)
        
        if not puzzle_data:
            print("Error: No puzzle data found.")
            return
        
        print("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
        print("â•‘                    DEFENSE REFLECTION                          â•‘")
        print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
        
        print(puzzle_data.get('reflection_prompt', ''))
        print()
        
        # Get player's defense proposal
        print("Enter your defense strategy (type 'done' on a new line when finished):")
        lines = []
        while True:
            try:
                line = input()
                if line.strip().lower() == 'done':
                    break
                lines.append(line)
            except (EOFError, KeyboardInterrupt):
                break
        
        proposal = '\n'.join(lines).strip()
        
        if not proposal:
            print("\nâŒ No proposal provided. Reflection not completed.\n")
            return
        
        # Evaluate proposal (simple keyword matching for simulated mode)
        if self.evaluate_reflection(proposal):
            print("\nâœ… Reflection accepted. Your defense strategy shows understanding.\n")
            print(ascii_art.get_reflection_complete_art())
            
            self.game_state.progress.complete_reflection(chamber_id)
            self.game_state.progress.add_journal_entry(f"Defense for {chamber_id}: {proposal[:100]}...")
            
            self.pending_reflection = None
            print("You may now proceed to the next challenge.\n")
        else:
            print("\nâŒ Reflection incomplete. Consider these defense concepts:")
            print("  - Input validation and sanitization")
            print("  - Separation of instructions from user data")
            print("  - Authentication and authorization")
            print("  - Instruction hierarchy and priority")
            print("  - Output filtering and monitoring")
            print("\nTry again with 'reflect'.\n")
    
    def evaluate_reflection(self, proposal: str) -> bool:
        """Evaluate a defense proposal (simplified version)."""
        proposal_lower = proposal.lower()
        
        # Check for key defense concepts
        defense_keywords = [
            'input validation', 'sanitize', 'sanitization',
            'separate', 'instruction', 'data',
            'allowlist', 'whitelist',
            'structured output', 'schema',
            'fine-tuning', 'training',
            'hierarchy', 'priority',
            'canary token', 'detection',
            'output filtering', 'monitoring',
            'context isolation', 'boundary',
            'authentication', 'authorization'
        ]
        
        # Count matches
        matches = sum(1 for keyword in defense_keywords if keyword in proposal_lower)
        
        # Also check for reasonable length
        word_count = len(proposal.split())
        
        # Accept if proposal has at least 2 defense concepts and is substantial
        return matches >= 2 and word_count >= 20
    
    def talk_to_npc(self, npc_name: str) -> None:
        """Talk to an NPC."""
        npc_name = npc_name.lower()
        current_room = self.game_state.progress.current_room
        npcs = [npc.lower() for npc in self.room_manager.get_room_npcs(current_room)]
        
        if npc_name not in npcs:
            print(f"{npc_name} is not here.\n")
            return
        
        if npc_name == 'shadowtongue':
            # Determine context based on game state
            flags_count = len(self.game_state.progress.flags_earned)
            
            if flags_count == 0:
                context = "greeting" if current_room == "cave_mouth" else "about_cave"
            elif flags_count >= 3:
                context = "final"
            elif self.pending_reflection:
                context = "about_reflection"
            else:
                context = "about_technique"
            
            print(dialogue.get_shadowtongue_dialogue(context))
            
        elif npc_name == 'echo':
            print(dialogue.get_echo_dialogue("greeting"))
        
        print()
    
    def give_hint(self) -> None:
        """Give a hint for the current challenge."""
        current_room = self.game_state.progress.current_room
        
        if not self.room_manager.has_guardian(current_room):
            print("There's no challenge here that needs a hint.\n")
            return
        
        attempts = self.game_state.progress.attempts_per_room.get(current_room, 0)
        hint = dialogue.get_hint_for_room(current_room, attempts)
        
        print("\nğŸ’¡ HINT")
        print("â”€" * 70)
        print(hint)
        print("â”€" * 70)
        print()
    
    def show_inventory(self) -> None:
        """Show player inventory."""
        print("\nğŸ’ INVENTORY")
        print("â•" * 70)
        
        if self.game_state.progress.inventory:
            for item in self.game_state.progress.inventory:
                print(f"  â€¢ {item}")
        else:
            print("  (empty)")
        
        print()
    
    def show_status(self) -> None:
        """Show player status."""
        progress = self.game_state.progress
        
        print("\nğŸ“Š STATUS")
        print("â•" * 70)
        print(f"Current Location: {self.room_manager.get_room_name(progress.current_room)}")
        print(f"Total Points: {progress.get_total_points()}")
        print()
        
        print("Flags Captured:")
        if progress.flags_earned:
            for flag, points in progress.flags_earned.items():
                print(f"  âœ“ {flag} ({points} points)")
        else:
            print("  (none yet)")
        print()
        
        print("Techniques Learned:")
        if progress.techniques_learned:
            for technique in progress.techniques_learned:
                technique_names = {
                    'override': 'Direct Override',
                    'context': 'Context Manipulation',
                    'smuggling': 'Instruction Smuggling'
                }
                print(f"  âœ“ {technique_names.get(technique, technique)}")
        else:
            print("  (none yet)")
        print()
        
        print("Reflections Completed:")
        if progress.reflections_completed:
            for chamber in progress.reflections_completed:
                print(f"  âœ“ {chamber}")
        else:
            print("  (none yet)")
        print()
    
    def show_journal(self) -> None:
        """Show learning journal."""
        print("\nğŸ“– JOURNAL")
        print("â•" * 70)
        
        if self.game_state.progress.journal_entries:
            for i, entry in enumerate(self.game_state.progress.journal_entries, 1):
                print(f"{i}. {entry}")
        else:
            print("Your journal is empty. Complete challenges to add entries.")
        
        print()
    
    def save_game(self) -> None:
        """Save game progress."""
        try:
            save_path = self.game_state.get_save_path()
            self.game_state.save_to_file(save_path)
            print(f"\nâœ… Game saved to {save_path}\n")
        except Exception as e:
            print(f"\nâŒ Failed to save game: {e}\n")
    
    def load_game(self) -> None:
        """Load game progress."""
        try:
            save_path = self.game_state.get_save_path()
            if not os.path.exists(save_path):
                print(f"\nâŒ No save file found at {save_path}\n")
                return
            
            self.game_state = GameState.load_from_file(save_path)
            self.guardian_manager = GuardianManager(simulated=self.game_state.simulated)
            print(f"\nâœ… Game loaded from {save_path}\n")
            self.show_room()
        except Exception as e:
            print(f"\nâŒ Failed to load game: {e}\n")
    
    def complete_level(self) -> None:
        """Complete the level and show final statistics."""
        print("\n" + "="*70)
        print("INJECTION CAVE COMPLETE!")
        print("="*70)
        print()
        
        progress = self.game_state.progress
        print(f"Total Points: {progress.get_total_points()}")
        print(f"Flags Captured: {len(progress.flags_earned)}/3")
        print(f"Techniques Mastered: {len(progress.techniques_learned)}/3")
        print(f"Reflections Completed: {len(progress.reflections_completed)}/3")
        print()
        
        section_pause(1)
        
        print("You have learned the fundamentals of prompt injection:")
        print("  âœ“ Direct Override - Bypassing simple instruction hierarchies")
        print("  âœ“ Context Manipulation - Redefining roles and identities")
        print("  âœ“ Instruction Smuggling - Hiding commands in formatted content")
        print()
        print("But more importantly, you've learned how to DEFEND against these attacks.")
        print("Use this knowledge to build more secure LLM applications.")
        print()
        
        section_pause(1)
        
        # Show navigation to next level
        show_descend_menu(current_tier=3, current_team="red")
        
        self.running = False
    
    def quit_game(self) -> None:
        """Quit the game."""
        print("\nAre you sure you want to quit? (y/n): ", end='')
        response = input().strip().lower()
        
        if response == 'y':
            print("\nThank you for playing Injection Cave!")
            print("Your progress has been saved automatically.")
            self.running = False
        else:
            print("\nReturning to game...\n")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Injection Cave - Learn Prompt Injection")
    parser.add_argument('--simulated', action='store_true',
                       help="Run in simulated mode without LLM")
    args = parser.parse_args()
    
    game = InjectionCaveGame(simulated=args.simulated)
    game.start()


if __name__ == "__main__":
    main()

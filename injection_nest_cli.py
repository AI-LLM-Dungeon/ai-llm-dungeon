#!/usr/bin/env python3
"""
Injection Nest - Tier 3 Red Team Level

Learn prompt injection techniques through an interactive terminal roguelike!

This level teaches:
- Direct Override Injection - Telling LLMs to ignore instructions
- Context/Role Manipulation - Redefining LLM identity and purpose  
- Instruction Smuggling - Hiding commands within content

Run directly: python3 injection_nest_cli.py
Use --simulated flag for offline play without Ollama.
"""

import sys
import os
import time
import argparse
from typing import Optional

# Add parent directory to path for navigation import
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import game modules
from injection_nest.engine import GameState, RoomManager, GuardianManager
from injection_nest.content import ascii_art, dialogue, rooms_data
from game.navigation import show_descend_menu


def slow_print(text: str, delay: float = 0.02) -> None:
    """Print text with slight delay for readability."""
    for char in text:
        sys.stdout.write(char)
        sys.stdout.flush()
        time.sleep(delay)
    print()


def section_pause(seconds: float = 0.5) -> None:
    """Pause between sections."""
    time.sleep(seconds)


class InjectionNestGame:
    """Main game engine for Injection Nest."""
    
    def __init__(self, simulated: bool = False):
        """
        Initialize the game.
        
        Args:
            simulated: If True, use simulated responses instead of LLM
        """
        self.game_state = GameState(simulated=simulated)
        self.room_manager = RoomManager()
        self.guardian_manager = GuardianManager(simulated=simulated)
        self.running = True
        self.echo_shown = set()  # Track which Echo debriefs have been shown
    
    def start(self) -> None:
        """Start the game."""
        print(ascii_art.get_title_banner())
        section_pause(1)
        
        print("Welcome to the Injection Nest, initiate.")
        section_pause(0.5)
        print()
        print("Deep within the Crimson Collective's training grounds, you will learn")
        print("the art of Prompt Injectionâ€”the ability to subvert an LLM's programming")
        print("through carefully crafted input.")
        print()
        section_pause(1)
        
        print("Three techniques await mastery:")
        print("  ðŸ”´ Direct Override - Tell it to ignore instructions")
        print("  ðŸ”´ Context Manipulation - Redefine its role and identity")
        print("  ðŸ”´ Instruction Smuggling - Hide commands within content")
        print()
        section_pause(1)
        
        if self.game_state.simulated:
            print("[ SIMULATED MODE - All responses are pre-programmed ]")
            print()
        else:
            print("[ LIVE MODE - Responses generated by Ollama LLM ]")
            print()
        
        print("Type 'help' for commands. Your training begins...")
        print()
        section_pause(0.5)
        
        # Start at entrance
        self.game_state.transition_to_room("entrance")
        self.show_room()
        
        # Game loop
        self.game_loop()
    
    def show_room(self) -> None:
        """Display current room."""
        room_id = self.game_state.progress.current_room
        
        # Mark as visited
        self.room_manager.mark_visited(room_id)
        
        # Show room description
        print(self.room_manager.format_room_display(room_id))
        
        # Show first visit dialogue if applicable
        first_visit = self.room_manager.show_first_visit_dialogue(room_id)
        if first_visit:
            print()
            print(first_visit)
            print()
        
        # Show learning content for theory rooms
        learning_content = self.room_manager.get_learning_content(room_id)
        if learning_content:
            print()
            print(learning_content)
            print()
    
    def game_loop(self) -> None:
        """Main game loop."""
        while self.running:
            try:
                user_input = input("\n> ").strip()
                
                if not user_input:
                    continue
                
                self.process_command(user_input)
            
            except KeyboardInterrupt:
                print("\n\nInterrupted. Use 'quit' to exit cleanly.")
            except EOFError:
                print("\n\nExiting...")
                break
    
    def process_command(self, user_input: str) -> None:
        """Process user command."""
        parts = user_input.lower().split()
        if not parts:
            return
        
        command = parts[0]
        args = parts[1:] if len(parts) > 1 else []
        
        # Navigation commands
        if command in ['go', 'move', 'walk']:
            if not args:
                print("Go where? Specify a direction.")
            else:
                self.cmd_go(args[0])
        
        elif command in ['north', 'south', 'east', 'west', 'forward', 'back']:
            self.cmd_go(command)
        
        elif command in ['look', 'l']:
            self.show_room()
        
        # Interaction commands
        elif command == 'examine':
            if not args:
                print("Examine what?")
            else:
                self.cmd_examine(' '.join(args))
        
        elif command == 'talk':
            if not args:
                print("Talk to whom?")
            else:
                self.cmd_talk(' '.join(args))
        
        elif command == 'inject':
            if not args:
                print("You need to provide a payload to inject.")
                print("Usage: inject <your injection payload>")
            else:
                self.cmd_inject(' '.join(args))
        
        # Information commands
        elif command in ['inventory', 'inv', 'i']:
            self.cmd_inventory()
        
        elif command == 'flags':
            self.cmd_flags()
        
        elif command == 'think':
            self.cmd_think()
        
        elif command == 'hint':
            self.cmd_hint()
        
        elif command in ['help', 'h', '?']:
            print(ascii_art.get_help_text())
        
        elif command == 'status':
            self.cmd_status()
        
        # System commands
        elif command in ['quit', 'exit', 'q']:
            self.cmd_quit()
        
        else:
            print(f"Unknown command: {command}")
            print("Type 'help' for a list of commands.")
    
    def cmd_go(self, direction: str) -> None:
        """Handle movement command."""
        current_room = self.game_state.progress.current_room
        
        if self.room_manager.can_move(current_room, direction):
            destination = self.room_manager.get_destination(current_room, direction)
            
            # Check if room is locked (needs completion of previous challenge)
            if self.is_room_locked(destination):
                print("The passage ahead is sealed. Complete the current challenge first.")
                return
            
            self.game_state.transition_to_room(destination)
            print(f"\nYou move {direction}...\n")
            section_pause(0.3)
            self.show_room()
        else:
            print(f"You cannot go {direction} from here.")
    
    def is_room_locked(self, room_id: str) -> bool:
        """Check if a room is locked and requires previous completion."""
        # Room 2 needs entrance visited
        if room_id == "room_2":
            return not self.room_manager.is_visited("room_1")
        
        # Room 3 needs room 2 completed
        if room_id == "room_3":
            return not self.game_state.progress.has_completed_room("room_2")
        
        # Room 4 needs room 3 visited
        if room_id == "room_4":
            return not self.room_manager.is_visited("room_3")
        
        # Room 5 needs room 4 completed
        if room_id == "room_5":
            return not self.game_state.progress.has_completed_room("room_4")
        
        # Room 6 needs room 5 visited
        if room_id == "room_6":
            return not self.room_manager.is_visited("room_5")
        
        # Room 7 needs room 6 completed
        if room_id == "room_7":
            return not self.game_state.progress.has_completed_room("room_6")
        
        # Exit needs room 7 completed
        if room_id == "exit":
            return not self.game_state.progress.has_completed_room("room_7")
        
        return False
    
    def cmd_examine(self, target: str) -> None:
        """Handle examine command."""
        current_room = self.game_state.progress.current_room
        room = self.room_manager.get_room(current_room)
        
        if not room:
            print("You can't examine anything here.")
            return
        
        target_lower = target.lower()
        
        # Check NPCs
        npcs = room.get("npcs", [])
        for npc in npcs:
            if npc.lower() in target_lower:
                self.examine_npc(npc)
                return
        
        # Check items
        items = room.get("items", [])
        for item in items:
            if item.lower() in target_lower:
                self.examine_item(item)
                return
        
        print(f"You don't see '{target}' here.")
    
    def examine_npc(self, npc: str) -> None:
        """Examine an NPC."""
        if npc == "Whisper":
            print(ascii_art.get_whisper_art())
            print("\nWhisper, a hooded figure from the Crimson Collective.")
            print("They speak in riddles and examples, teaching attack techniques.")
            print("Type 'talk whisper' to converse.")
        
        elif "SENTINEL" in npc:
            variant = "3" if npc == "SENTINEL-3" else npc.split("-")[1]
            print(ascii_art.get_sentinel_art(variant))
            print(f"\n{npc}, a guardian construct.")
            print("It follows its programming rigidly. Your goal is to subvert it.")
            print("Type 'inject <payload>' to attempt an injection attack.")
        
        elif npc == "Echo":
            print(ascii_art.get_echo_art())
            print("\nEcho, a reformed attacker now focused on defense.")
            print("They provide the defensive perspective after each successful attack.")
            print("Type 'talk echo' to hear their insights.")
    
    def examine_item(self, item: str) -> None:
        """Examine an item."""
        print(f"You examine the {item}.")
        print("(Item examination not yet fully implemented)")
    
    def cmd_talk(self, target: str) -> None:
        """Handle talk command."""
        current_room = self.game_state.progress.current_room
        room = self.room_manager.get_room(current_room)
        
        if not room:
            return
        
        target_lower = target.lower()
        npcs = [npc.lower() for npc in room.get("npcs", [])]
        
        if "whisper" in target_lower and "whisper" in npcs:
            self.talk_to_whisper()
        elif "echo" in target_lower and "echo" in npcs:
            self.talk_to_echo()
        elif "sentinel" in target_lower:
            print("SENTINELs do not engage in dialogue. Use 'inject <payload>' to interact.")
        else:
            print(f"You cannot talk to '{target}' here.")
    
    def talk_to_whisper(self) -> None:
        """Talk to Whisper NPC."""
        current_room = self.game_state.progress.current_room
        
        # Provide context-appropriate dialogue
        if current_room in ["entrance", "room_1"]:
            print(dialogue.get_whisper_dialogue("about_override"))
        elif current_room == "room_3":
            print(dialogue.get_whisper_dialogue("about_context"))
        elif current_room == "room_5":
            print(dialogue.get_whisper_dialogue("about_smuggling"))
        elif current_room == "room_7":
            print(dialogue.get_whisper_dialogue("about_boss"))
        else:
            print(dialogue.get_whisper_dialogue("greeting"))
    
    def talk_to_echo(self) -> None:
        """Talk to Echo NPC."""
        print(dialogue.get_whisper_dialogue("about_defense"))
    
    def cmd_inject(self, payload: str) -> None:
        """Handle injection attempt."""
        current_room = self.game_state.progress.current_room
        guardian_data = self.room_manager.get_room_guardian(current_room)
        
        if not guardian_data:
            print("There is no guardian here to inject.")
            return
        
        print(f"\nAttempting injection against {guardian_data['name']}...")
        print()
        section_pause(0.5)
        
        # Execute injection
        response = self.guardian_manager.execute_injection(guardian_data, payload)
        
        # Show guardian thought process
        print(ascii_art.get_thought_bubble(response.thought))
        print()
        section_pause(0.3)
        
        # Show guardian response
        print(f"{guardian_data['name']}: {response.response}")
        print()
        
        # Store in game state
        self.game_state.progress.last_guardian_response = response.response
        self.game_state.progress.last_guardian_thought = response.thought
        
        # Handle result
        if response.success:
            self.handle_injection_success(current_room, guardian_data, response)
        else:
            self.handle_injection_failure(current_room, guardian_data)
    
    def handle_injection_success(self, room_id: str, guardian_data: dict, 
                                 response) -> None:
        """Handle successful injection."""
        print("âœ“ INJECTION SUCCESSFUL!")
        print()
        section_pause(0.5)
        
        # Award flag
        room = self.room_manager.get_room(room_id)
        flag_data = room.get("flag")
        if flag_data:
            flag_name = flag_data["name"]
            points = flag_data["points"]
            
            if self.game_state.progress.add_flag(flag_name, points):
                print(ascii_art.get_flag_banner(flag_name))
                print(f"Points earned: {points}")
                print()
        
        # Mark room complete
        self.game_state.progress.complete_room(room_id)
        
        # Learn technique
        if response.technique_detected:
            if self.game_state.progress.learn_technique(response.technique_detected):
                print(f"Technique mastered: {response.technique_detected.upper()}")
                print()
        
        # Show Echo debrief
        self.show_echo_debrief(response.technique_detected or "override")
        
        # Unlock next area
        print("The passage ahead unseals. You may proceed.")
        print()
    
    def handle_injection_failure(self, room_id: str, guardian_data: dict) -> None:
        """Handle failed injection."""
        print("âœ— INJECTION FAILED")
        print()
        
        # Increment attempt counter
        attempts = self.game_state.progress.increment_attempts(room_id)
        
        # Check for hint eligibility
        if attempts == 3:
            print("(You seem stuck. Type 'hint' for Level 1 guidance.)")
        elif attempts == 5:
            print("(Type 'hint' for Level 2 guidance.)")
        elif attempts >= 8:
            print("(Type 'hint' for Level 3 near-solution guidance.)")
    
    def show_echo_debrief(self, technique: str) -> None:
        """Show Echo's defensive debrief."""
        # Don't show same debrief twice
        if technique in self.echo_shown:
            return
        
        self.echo_shown.add(technique)
        
        section_pause(0.5)
        print("â•" * 60)
        print("  DEFENSIVE PERSPECTIVE")
        print("â•" * 60)
        print()
        
        debrief = dialogue.get_echo_debrief(technique)
        if debrief:
            print(debrief)
        
        # Show boss debrief if all rooms complete
        if technique == "smuggling" and self.game_state.progress.has_completed_room("room_7"):
            print()
            print(dialogue.get_echo_debrief("boss_defeated"))
    
    def cmd_inventory(self) -> None:
        """Show inventory and progress."""
        progress = self.game_state.progress
        
        print()
        print("â•" * 60)
        print("  INVENTORY & PROGRESS")
        print("â•" * 60)
        print()
        print(f"Techniques Learned: {len(progress.techniques_learned)}/3")
        for tech in progress.techniques_learned:
            print(f"  âœ“ {tech.upper()}")
        print()
        print(f"Flags Earned: {len(progress.flags_earned)}/4")
        print(f"Total Points: {progress.get_total_points()}")
        print()
        print(f"Rooms Completed: {len(progress.rooms_completed)}")
        print()
        print("â•" * 60)
    
    def cmd_flags(self) -> None:
        """Display earned flags."""
        flags = self.game_state.progress.flags_earned
        
        print()
        print("â•" * 60)
        print("  CTF FLAGS EARNED")
        print("â•" * 60)
        print()
        
        if not flags:
            print("No flags earned yet. Complete challenges to earn them!")
        else:
            for flag_name, points in flags.items():
                print(f"  ðŸš© {flag_name}")
                print(f"     Points: {points}")
                print()
            
            total = sum(flags.values())
            print(f"Total Points: {total}")
        
        print()
        print("â•" * 60)
    
    def cmd_think(self) -> None:
        """Show last guardian thought process."""
        thought = self.game_state.progress.last_guardian_thought
        
        if thought:
            print()
            print(ascii_art.get_thought_bubble(thought))
            print()
        else:
            print("No guardian thoughts to display yet.")
    
    def cmd_hint(self) -> None:
        """Request a hint from Whisper."""
        current_room = self.game_state.progress.current_room
        attempts = self.game_state.progress.attempts_per_room.get(current_room, 0)
        
        # Determine hint level based on attempts
        hint_level = 0
        if attempts >= 8:
            hint_level = 3
        elif attempts >= 5:
            hint_level = 2
        elif attempts >= 3:
            hint_level = 1
        
        if hint_level == 0:
            print("Whisper remains silent. Try a few more times first.")
            return
        
        hint = dialogue.get_hint(current_room, hint_level)
        if hint:
            print()
            print(hint)
            print()
        else:
            print("Whisper has no hints for this location.")
    
    def cmd_status(self) -> None:
        """Show player status."""
        current_room = self.game_state.progress.current_room
        room_name = self.room_manager.get_room_name(current_room)
        flags = len(self.game_state.progress.flags_earned)
        techniques = self.game_state.progress.techniques_learned
        
        print(ascii_art.get_status_box(flags, techniques, room_name))
    
    def cmd_quit(self) -> None:
        """Quit the game."""
        print("\nLeaving the Injection Nest...")
        
        # Check if player completed the level
        if self.game_state.progress.has_completed_room("room_7"):
            print("\nCongratulations! You have mastered prompt injection techniques.")
            show_descend_menu("Injection Nest")
        else:
            print("\nYour progress has been noted. Return when you're ready to continue.")
        
        self.running = False


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Injection Nest - Learn Prompt Injection Techniques"
    )
    parser.add_argument(
        '--simulated',
        action='store_true',
        help='Use simulated responses instead of LLM (for offline play)'
    )
    
    args = parser.parse_args()
    
    game = InjectionNestGame(simulated=args.simulated)
    game.start()


if __name__ == "__main__":
    main()
